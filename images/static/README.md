<!--monopod:start-->
# static
| | |
| - | - |
| **OCI Reference** | `cgr.dev/chainguard/static` |


* [View Image in Chainguard Academy](https://edu.chainguard.dev/chainguard/chainguard-images/reference/static/overview/)
* [View Image Catalog](https://console.enforce.dev/images/catalog) for a full list of available tags.
* [Contact Chainguard](https://www.chainguard.dev/chainguard-images) for enterprise support, SLAs, and access to older tags.*

---
<!--monopod:end-->

<!--overview:start-->
Base images with the minimum contents needed to run static binaries.
<!--overview:end-->

<!--getting:start-->
## Download this Image
The image is available on `cgr.dev`:

```
docker pull cgr.dev/chainguard/static:latest
```
<!--getting:end-->

<!--body:start-->
## Usage

Chainguard's static Images are meant to be used as a base image only and are not intended to be run directly.

There are two variants of the static Image available: `latest`, which contains base OS files from
[Alpine](https://www.alpinelinux.org/) and `latest-glibc` which contains base OS files from
[Wolfi](https://github.com/wolfi-dev/os). These variants are largely equivalent and can be used to host completely static binaries, such as those generated by `gcc`, `rust`, or `go`. Be aware that there is no libc implementation in either Image, despite the naming convention.

If you need images with the C standard library included, check out Chainguard's  [glibc-dynamic](https://github.com/chainguard-images/images/tree/main/images/glibc-dynamic) Image.

This Image has a single user `nonroot` with uid `65532`, belonging to gid `65532`.

### Rust Dockerfile Example

This section outlines how to build a Rust static binary with Chainguard's static Image. First, create a Dockerfile named `Dockerfile.rust` with your preferred text editor.

```shell
nano Dockerfile.rust
```

Then add the following instructions to the file, which build a Rust static binary and put it into the static Image:

```Dockerfile
FROM cgr.dev/chainguard/rust as build

RUN echo 'fn main() { println!("Hello Rust users!"); }' > hello.rs
RUN rustc -C target-feature=+crt-static hello.rs

FROM cgr.dev/chainguard/static:latest

COPY --from=build /work/hello /hello
CMD ["/hello"]
```

Save and close the file. To build the binary, run the following command:

```shell
docker build -t rusty-cgr --file Dockerfile.rust .
```

This command tags the binary with `rusty-cgr`. You can run this newly-built Image with the following command:

```shell
docker run rusty-cgr
```
```
Hello Rust users!
```

If you inspect this image, you'll find that it has a relatively small size:

```shell
docker images rusty-cgr
```
```
REPOSITORY   TAG   	IMAGE ID   	CREATED      	SIZE
rusty-cgr	latest	dd789eb1c964   35 seconds ago   3.98MB
```

### C Dockerfile Example

This section is similar to the previous one, but instead outlines how to build a C static binary. This time, create a Dockerfile named `Dockerfile.c` with your preferred text editor:

```shell
nano Dockerfile.c
```

Add the following instructions to the file:

```Dockerfile
# syntax=docker/dockerfile:1.4
FROM cgr.dev/chainguard/gcc-glibc as build

COPY <<EOF /hello.c
#include <stdio.h>
int main() { printf("Hello C users!"); }
EOF
RUN cc -static /hello.c -o /hello

FROM cgr.dev/chainguard/static:latest

COPY --from=build /hello /hello
CMD ["/hello"]
```

After saving and closing the Dockerfile, you can build the binary:

```shell
docker build -t c-cgr -f Dockerfile.c .
```

Then run it by referencing the tag `c-cgr`:

```shell
docker run c-cgr
```
```
Hello C users!
```

Inspect this newly-built image as well. 

```shell
docker images c-cgr
```
```
REPOSITORY   TAG   	IMAGE ID   	CREATED      	SIZE
c-cgr    	latest	fc18c6e71f95   33 seconds ago   3.36MB
```

This C static binary is even smaller than the Rust one built in the previous section.
<!--body:end-->
