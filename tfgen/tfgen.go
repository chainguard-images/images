package main

import (
	"fmt"
	"log"
	"os"
	"sort"

	"github.com/hashicorp/hcl/v2"
	"github.com/hashicorp/hcl/v2/gohcl"
	"github.com/hashicorp/hcl/v2/hclparse"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	"github.com/spf13/cobra"
	"github.com/zclconf/go-cty/cty"
)

type MainConfig struct {
	Modules []Module `hcl:"module,block"`
	Remain  hcl.Body `hcl:",remain"`
}

type Module struct {
	Name   string   `hcl:"name,label"`
	Source string   `hcl:"source"`
	Remain hcl.Body `hcl:",remain"`
}

type OutputImages struct {
	Name   string `hcl:"name,label"`
	Images []string
	Remain hcl.Body `hcl:",remain"`
}

type TFVars struct {
	Images map[string]string `hcl:"images"`
	Remain hcl.Body          `hcl:",remain"`
}

type opts struct {
	Root string
}

func main() {
	o := &opts{}

	root := &cobra.Command{
		Use: "tfgen",
		RunE: func(cmd *cobra.Command, args []string) error {
			return o.run()
		},
	}

	root.Flags().StringVar(&o.Root, "root", ".", "Path to terraform root")

	if err := root.Execute(); err != nil {
		log.Fatalf("error during command execution: %v", err)
	}
}

func (o *opts) run() error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	defer os.Chdir(cwd)
	if err := os.Chdir(o.Root); err != nil {
		return err
	}

	ivars, err := hclFile("images.auto.tfvars")
	if err != nil {
		return err
	}

	hf := hclwrite.NewEmptyFile()

	tfvars := &TFVars{}
	if diag := gohcl.DecodeBody(ivars.Body, nil, tfvars); diag.HasErrors() {
		return diag
	}

	outputs := &OutputImages{
		Name:   "images",
		Images: make([]string, 0, len(tfvars.Images)),
	}

	images := make([]string, 0, len(tfvars.Images))
	for image := range tfvars.Images {
		images = append(images, image)
	}
	sort.Strings(images)

	for _, image := range images {
		m := &Module{
			Name:   image,
			Source: tfvars.Images[image],
		}

		// Ensure the source exists
		if _, err := os.Stat(m.Source); err != nil {
			panic(err)
		}

		iblock := m.Encode()
		hf.Body().AppendBlock(iblock)
		hf.Body().AppendNewline() // Aesthetics are key here

		outputs.Images = append(outputs.Images, m.Name)
	}

	outputBody := outputs.Encode()
	hf.Body().AppendBlock(outputBody)

	// Create a new images.tf
	imagesf, err := os.OpenFile("images.tf", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		panic(err)
	}
	defer imagesf.Close()

	fmt.Fprint(imagesf, "# DO NOT EDIT. This file is autogenerated by tfgen.\n")
	fmt.Fprintf(imagesf, "%s", hf.Bytes())

	return nil
}

func hclFile(path string) (*hcl.File, error) {
	raw, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	f, diags := hclparse.NewParser().ParseHCL(raw, path)
	if diags.HasErrors() {
		return nil, diags
	}

	return f, nil
}

func (m Module) Encode() *hclwrite.Block {
	b := hclwrite.NewBlock("module", []string{m.Name})
	b.Body().SetAttributeValue("source", cty.StringVal(m.Source))

	// We have to set the target_repository attribute tokens manually due to the variable interpolation required
	b.Body().SetAttributeRaw("target_repository", hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenOQuote,
			Bytes: []byte(`"`),
		},
		{
			Type:  hclsyntax.TokenIdent,
			Bytes: []byte(fmt.Sprintf("${var.target_repository}/%s", m.Name)),
		},
		{
			Type:  hclsyntax.TokenCQuote,
			Bytes: []byte(`"`),
		},
	})
	return b
}

func (o OutputImages) Encode() *hclwrite.Block {
	b := hclwrite.NewBlock("output", []string{o.Name})

	itok := hclwrite.Tokens{}
	itok = append(itok, hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenOBrace,
			Bytes: []byte("{"),
		},
		{
			Type:  hclsyntax.TokenNewline,
			Bytes: []byte("\n"),
		},
	}...)

	for _, image := range o.Images {
		val := hcl.Traversal{
			hcl.TraverseRoot{Name: "module"},
			hcl.TraverseAttr{Name: image},
			hcl.TraverseAttr{Name: "images"},
		}

		itok = append(itok, hclwrite.Tokens{
			{
				Type:  hclsyntax.TokenIdent,
				Bytes: []byte(image),
			},
			{
				Type:  hclsyntax.TokenEqual,
				Bytes: []byte("="),
			},
		}...)
		itok = append(itok, hclwrite.TokensForTraversal(val)...)
		itok = append(itok, hclwrite.Tokens{
			{
				Type:  hclsyntax.TokenNewline,
				Bytes: []byte("\n"),
			},
		}...)
	}

	itok = append(itok, hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenCBrace,
			Bytes: []byte("}"),
		},
	}...)

	b.Body().SetAttributeRaw("value", itok)

	return b
}
