name: release-image
inputs:
  slackWebhookUrl:
    default: ''
  gcsBucketName:
    default: ''
runs:
  using: composite
  steps:
    - uses: actions/checkout@v3

    # Run custom melange build if necessary
    - name: Setup QEMU
      if: inputs.melangeConfig != ''
      uses: docker/setup-qemu-action@v2.1.0
    - id: melange
      if: inputs.melangeConfig != ''
      uses: chainguard-dev/actions/melange-build@main
      with:
        config: ${{ inputs.melangeConfig }}
        empty-workspace: true
        sign-with-temporary-key: true
        archs: ${{ inputs.melangeArchs }}
        template: ${{ inputs.melangeTemplate }}

    # If publishing to GCR, setup OIDC->SA auth
    - id: gcrauth1
      if: startsWith(inputs.apkoBaseTag, 'gcr.io/')
      uses: google-github-actions/auth@c4799db9111fba4461e9f9da8732e5057b394f72 #v0
      with:
        workload_identity_provider: ${{ inputs.gcrAuthWorkloadIdentityProvider }}
        service_account: ${{ inputs.gcrAuthServiceAccount }}
    - id: gcrauth2
      if: startsWith(inputs.apkoBaseTag, 'gcr.io/')
      uses: google-github-actions/setup-gcloud@877d4953d2c70a0ba7ef3290ae968eb24af233bb #v0.6.0
      with:
        project_id: ${{ inputs.gcrAuthProjectId }}
        install_components: beta
    - id: gcrauth3
      if: startsWith(inputs.apkoBaseTag, 'gcr.io/')
      shell: bash
      run: |
        gcloud auth configure-docker

    # Build and push
    - id: apko
      uses: chainguard-images/actions/apko-snapshot@main
      with:
        config: ${{ inputs.apkoConfig }}
        base-tag: ${{ inputs.apkoBaseTag }}
        target-tag: ${{ inputs.apkoTargetTag }}
        keyring-append: ${{ inputs.apkoKeyringAppend }}
        additional-tags: ${{ inputs.apkoAdditionalTags }}
        package-version-tag: ${{ inputs.apkoPackageVersionTag }}
        package-version-tag-stem: true
        package-version-tag-prefix: ${{ inputs.apkoPackageVersionTagPrefix }}
    - name: Extract the digests for each architecture
      id: extract
      shell: bash
      run: |
        for combo in `crane manifest ${{ steps.apko.outputs.digest }} | jq -r '.manifests[] | .platform.architecture + .platform.variant + "_" + .digest'`; do
          arch="$(echo "${combo}" | cut -d "_" -f1)"
          digest="$(echo "${combo}" | cut -d "_" -f2)"
          output="digest-${arch}=${{ inputs.apkoBaseTag }}@${digest}"
          echo "Adding GitHub step output: ${output}"
          echo "${output}" >> $GITHUB_OUTPUT
        done
        output="digest-index=${{ steps.apko.outputs.digest }}"
        echo "Adding GitHub step output: ${output}"
        echo "${output}" >> $GITHUB_OUTPUT

    # Test image
    - name: Smoke test
      id: smoketest
      if: inputs.testCommandExe != ''
      shell: bash
      run: |
        set -x
        export IMAGE_NAME="${{ steps.extract.outputs.digest-index }}"
        cd "${{ inputs.testCommandDir }}"
        ${{ inputs.testCommandExe }}

    # Scan - first index, then amd64, then arm64, then others
    # TODO: improve this - make a single action that runs multiple, or run in matrix at top level
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-index
      if: steps.extract.outputs.digest-index != ''
      with:
        image: ${{ steps.extract.outputs.digest-index }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-amd64
      if: steps.extract.outputs.digest-amd64 != ''
      with:
        image: ${{ steps.extract.outputs.digest-amd64 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-arm64
      if: steps.extract.outputs.digest-arm64 != ''
      with:
        image: ${{ steps.extract.outputs.digest-arm64 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-386
      if: steps.extract.outputs.digest-386 != ''
      with:
        image: ${{ steps.extract.outputs.digest-386 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-armv6
      if: steps.extract.outputs.digest-armv6 != ''
      with:
        image: ${{ steps.extract.outputs.digest-armv6 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-armv7
      if: steps.extract.outputs.digest-armv7 != ''
      with:
        image: ${{ steps.extract.outputs.digest-armv7 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-ppc64le
      if: steps.extract.outputs.digest-ppc64le != ''
      with:
        image: ${{ steps.extract.outputs.digest-ppc64le }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-riscv64
      if: steps.extract.outputs.digest-riscv64 != ''
      with:
        image: ${{ steps.extract.outputs.digest-riscv64 }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'
    - uses: chainguard-images/actions/vul-scans@main
      id: scan-s390x
      if: steps.extract.outputs.digest-s390x != ''
      with:
        image: ${{ steps.extract.outputs.digest-s390x }}
        RUN_SNYK: 'false'
        DOCKER_LOGIN: 'false'

    # Generate build status badge from shields.io and save it in ./badges-output/
    - if: always()
      name: BADGINATOR-5000.sh
      shell: bash
      env:
        NAME: ${{ inputs.imageName }}
        VARIANT: ${{ inputs.apkoTargetTag }}
        TAGS: ${{ inputs.apkoAdditionalTags }}
      run: |
        set -x
        cat <<EOF > BADGINATOR-5000.sh
        BADGE_COLOR="\$1"
        BADGE_LABEL="$VARIANT"
        FILENAME_LATEST="$NAME.build.status.latest.svg"
        FILENAME_VARIANT="$NAME.build.status.$VARIANT.svg"
        [[ "$TAGS" == "" ]] || BADGE_LABEL="\$BADGE_LABEL%20%28$TAGS%29"
        mkdir -p badges-output
        curl -v -L -o "badges-output/\$FILENAME_VARIANT" "https://img.shields.io/static/v1?label=\$BADGE_LABEL&message=%20&color=\$BADGE_COLOR"
        if [[ "$TAGS" == "latest" && "\$FILENAME_VARIANT" != "\$FILENAME_LATEST" ]]; then
          cp "badges-output/\$FILENAME_VARIANT" "badges-output/\$FILENAME_LATEST"
        fi
        EOF
    - if: failure()
      shell: bash
      run: |
        set -x && trap "rm -f BADGINATOR-5000.sh" EXIT && bash -ex BADGINATOR-5000.sh critical
    - if: success()
      shell: bash
      run: |
        set -x && trap "rm -f BADGINATOR-5000.sh" EXIT && bash -ex BADGINATOR-5000.sh success

    # There is currently no way to obtain the job ID for a single matrix leg, so we have to
    # try to hit the GitHub API and match the job based on the name, then extract the html_url
    # See the following issue for more details: https://github.com/orgs/community/discussions/40291
    - shell: bash
      if: failure() && inputs.slackWebhookUrl != ''
      id: slacklink
      run: |
        set -x
        function get_actions_job_url {
          curl -vL -H "Authorization: Bearer ${{ github.token }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" \
            | jq -r ".jobs[] | select(.name | contains(\"${1}\")) | .html_url"
        }
        if [[ "${{ inputs.melangeConfig }}" != "" ]]; then
          export ACTIONS_URL="$(get_actions_job_url ${{ inputs.melangeConfig }})"
        else
          export ACTIONS_URL="$(get_actions_job_url ${{ inputs.apkoConfig }})"
        fi
        export ACTIONS_URL="${ACTIONS_URL:-https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}}"
        echo "link=${ACTIONS_URL}" >> $GITHUB_OUTPUT

    # Slack notification if build failing
    - uses: slackapi/slack-github-action@007b2c3c751a190b6f0f040e47ed024deaa72844 #v1.23.0
      if: failure() && inputs.slackWebhookUrl != ''
      id: slack
      with:
        payload: '{"text": "${{ inputs.imageName }} ${{ inputs.apkoTargetTag }} failed: ${{ steps.slacklink.outputs.link }}"}'
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.slackWebhookUrl }}
        SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

    # Upload badges from ./badges-output/
    - uses: actions/upload-artifact@v3
      if: always()
      with:
        name: badges
        path: badges-output

    # TODO: Upload badges to GCS bucket (if specified)
    - id: gcsauth1
      if: always() && inputs.gcsBucketName != ''
      uses: google-github-actions/auth@c4799db9111fba4461e9f9da8732e5057b394f72 #v0
      with:
        workload_identity_provider: ${{ inputs.gcsAuthWorkloadIdentityProvider }}
        service_account: ${{ inputs.gcsAuthServiceAccount }}
    - id: gcsauth2
      if: always() && inputs.gcsBucketName != ''
      uses: google-github-actions/setup-gcloud@877d4953d2c70a0ba7ef3290ae968eb24af233bb #v0.6.0
      with:
        project_id: ${{ inputs.gcsAuthProjectId }}
        install_components: beta
    - id: gcsupload1
      if: always() && inputs.gcsBucketName != ''
      shell: bash
      run: |
        gsutil rsync badges-output/ gs://${{ inputs.gcsBucketName }}/badges

    - name: Touch actions file to prevent postrun failure
      if: always()
      shell: bash
      run: |
        set -x && [[ -f .github/actions/release-image/action.yml ]] || ( \
          mkdir -p .github/actions/release-image/ && echo 'runs: {using: composite, steps: []}' > .github/actions/release-image/action.yml )
